<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris</title>
    <style>
      /* Basic styling for the game */
      html,
      body {
        height: 100%;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #222;
        font-family: sans-serif;
      }
      canvas {
        display: block;
        background-color: #000;
        border: 1px solid #fff;
      }
    </style>
  </head>
  <body>
    <!-- Tetris game canvas -->
    <canvas id="gameCanvas" width="200" height="400"></canvas>
    <script>
      // Tetris main logic
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scale = 20;
      // Tetromino shapes
      const shapes = [
        [
          [1, 1, 1],
          [0, 1, 0],
        ], // T
        [
          [0, 1, 1],
          [1, 1, 0],
        ], // Z
        [
          [1, 1, 0],
          [0, 1, 1],
        ], // S
        [
          [1, 1],
          [1, 1],
        ], // O
        [[1, 1, 1, 1]], // I
        [
          [1, 1, 1],
          [1, 0, 0],
        ], // L
        [
          [1, 1, 1],
          [0, 0, 1],
        ], // J
      ];

      // Initialize game state
      let grid = Array.from({ length: 20 }, () => Array(10).fill(0));
      let tetromino, position;

      // Spawn a new tetromino
      function spawn() {
        tetromino = shapes[Math.floor(Math.random() * shapes.length)];
        position = { x: Math.floor(grid[0].length / 2) - 1, y: 0 };
      }

      // Check if tetromino can be moved to a new position
      function canMove(newPosition, newTetromino = tetromino) {
        for (let y = 0; y < newTetromino.length; y++) {
          for (let x = 0; x < newTetromino[y].length; x++) {
            if (
              newTetromino[y][x] &&
              (newPosition.y + y >= grid.length ||
                newPosition.x + x < 0 ||
                newPosition.x + x >= grid[0].length ||
                grid[newPosition.y + y][newPosition.x + x])
            ) {
              return false;
            }
          }
        }
        return true;
      }

      // Rotate tetromino
      function rotate() {

        const newTetromino = tetromino[0]
          .map((_, i) => tetromino.map((row) => row[i]))
          .reverse();
        if (canMove(position, newTetromino)) tetromino = newTetromino;
      }

      // Merge tetromino with grid and check for full lines
      function merge() {
        for (let y = 0; y < tetromino.length; y++) {
          for (let x = 0; x < tetromino[y].length; x++) {
            if (tetromino[y][x]) {
              grid[position.y + y][position.x + x] = 1;
            }
          }
        }
        let linesCleared = 0;
        for (let y = grid.length - 1; y >= 0; ) {
          if (grid[y].every((cell) => cell)) {
            grid.splice(y, 1);
            grid.unshift(Array(10).fill(0));
            linesCleared++;
          } else {
            y--;
          }
        }

        if (linesCleared) {
          // Score logic can be added here
        }
      }

      // Game over condition
      function isGameOver() {
        return !canMove(position);
      }

      // Draw the game state
      function draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function drawCells(cells, offset = { x: 0, y: 0 }) {
          for (let y = 0; y < cells.length; y++) {
            for (let x = 0; x < cells[y].length; x++) {
              if (cells[y][x]) {
                ctx.fillStyle = "white";
                ctx.fillRect(
                  (x + offset.x) * scale,
                  (y + offset.y) * scale,
                  scale,
                  scale
                );
                ctx.strokeStyle = "#000";
                ctx.strokeRect(
                  (x + offset.x) * scale,
                  (y + offset.y) * scale,
                  scale,
                  scale
                );
              }
            }
          }
        }

        drawCells(grid);
        drawCells(tetromino, position);
      }

      // Game loop
      function update() {
        if (canMove({ x: position.x, y: position.y + 1 })) {
          position.y++;
        } else {
          merge();
          spawn();
          if (isGameOver()) {
            grid = Array.from({ length: 20 }, () => Array(10).fill(0));
          }
        }

        draw();
        setTimeout(update, 1000 / 2);
      }

      // Keyboard controls
      document.addEventListener("keydown", (e) => {
        const newPosition = { x: position.x, y: position.y };
        if (e.code === "ArrowLeft") newPosition.x--;
        if (e.code === "ArrowRight") newPosition.x++;
        if (e.code === "ArrowDown") newPosition.y++;
        if (canMove(newPosition)) {
          position = newPosition;
        }  
        if (e.code === "ArrowUp") {
          rotate();
        }
      });

      // Start the game
      spawn();
      update();
    </script>
  </body>
</html>
